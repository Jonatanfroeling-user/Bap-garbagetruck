const initWithMap = (MAP, locationData, routeData, iconUserA, iconUserB) => {
  const { log } = console;

  let Grid, offlineServer;

  const mapCenter = [50.745, 3.62];
  const stepDestail = 0.0001;

  /** Helpers */
  function sleep(s = 0.1) {
    return new Promise((resolve) => setTimeout(resolve, s * 1000));
  }

  function toFixed(nr, amt = 6) {
    return +nr.toFixed(amt);
  }

  function getDis(a, b) {
    return Math.hypot(b[0] - a[0], b[1] - a[1]);
  }

  JSON.copy = (a) => JSON.parse(JSON.stringify(a));

  Object.defineProperty(Array.prototype, "current", {
    value: 0,
    writable: true,
    enumerable: false,
  });

  Array.prototype.next = function () {
    if (this.current >= this.length - 1) this.current = -1;
    return this[this.current++];
  };

  Array.prototype.getCurrent = function () {
    return this.current;
  };

  function getPosTo(src, targ, dis) {
    const dx = targ[0] - src[0];
    const dy = targ[1] - src[1];
    let angle = Math.atan2(dy, dx);

    return [src[0] + dis * Math.cos(angle), src[1] + dis * Math.sin(angle)];
  }

  // truck icon
  function getIcon(coords, isPrimaryuser = true) {
    const LeafIcon = window.L.Icon.extend({
      options: {
        iconSize: [50, 30],
      },
    });
    const icon = new LeafIcon({
      iconUrl: isPrimaryuser ? iconUserA : iconUserB,
    });
    return new window.L.marker(coords, {
      icon: icon,
    }).addTo(MAP);
  }

  /** get itermediate points */
  function getIntermediate(a, b) {
    let steps = stepDestail;
    const res = [];
    let dis = Infinity;
    let c = null;
    let tracker = 0;

    while (dis > steps) {
      if (tracker > 1000) throw new Error("infinite loop at: getIntermediate");
      c = getPosTo(a, b, tracker);
      dis = getDis(c, b);
      tracker += steps;
      res.push(c.map((i) => toFixed(i, 6)));
    }
    return res;
  }

  /** Street & nodes */
  // a street node point
  class StreetNode {
    constructor(id, partId, coords, street) {
      this.coords = coords;
      this.partId = partId;
      this.street = street;
      this.x = coords[0];
      this.y = coords[1];

      this.checked = false;
    }
    setChecked() {
      if (this.checked) return;
      this.checked = true;
      this.street.updateStreetStats();
    }
  }

  // a street part exists out of multiple nodes
  // it also contains the SVG leaflet marker item, and the user
  class StreetPart {
    constructor(partId, nodes, street) {
      //this.id = id
      this.nodes = nodes;
      this.partId = partId;
      this.street = street;
      this.rawNodes = [...nodes.values()].map((i) => i.coords);

      this.marker = null;
      this.finished = false;
    }

    checkPartDone() {
      if (this.finished) return this.nodes.length;
      const progress = [...this.nodes.values()].filter((i) => i.checked).length;
      if (progress === this.nodes.length) {
        this.finished = true;
        this.marker.setStyle({ color: "green" });
      }

      return progress;
    }

    setMarker() {
      this.marker = window._mapFunctions.createMarker(
        this.partId,
        this.rawNodes
      );
    }
    removeMarker() {
      MAP.removeLayer(this.marker);
      this.marker = null;
    }
  }

  // a street exists out of multiple street parts
  class Street {
    constructor(name, rawParts) {
      this.name = name;
      this.parts = new Map();
      this.rawParts = rawParts;
      this.nodes = [];
      this.max = 0;
      this.progress = 0;
      this.done = false;
    }
    addPart(nodes, partId) {
      this.parts.set(this.parts.size, new StreetPart(partId, nodes, this));
      this.max += nodes.size;
      this.nodes.push(...nodes.values());

      return this.parts.get(this.parts.size - 1);
    }
    // adds user to all parts
    setUser(user) {
      this.user = user;
    }

    updateStreetStats() {
      let totalParts = 0;
      for (let part of this.parts.values()) {
        totalParts += part.checkPartDone();
      }
      totalParts /= this.parts.size;

      this.progress = totalParts;
      this.percentage = Math.round((this.progress / this.max) * 100);

      window._progress[this.name] = this.percentage;
      return this.percentage;
    }
  }

  // overview of all data, basically all data related to the roads
  class RouteClass {
    constructor(id, user = null) {
      this.id = id;
      // reverse lookup by street name
      this.lookupStreet = new Map();
      // store all streets by coordinates.
      // Used for reversed lookup the road by coordinates
      this.lookupNodes = new Map();
      // reverse lookup part of street in case of switching it to another user
      this.lookupPart = new Map();

      this.done = 0;
      this.todo = 100;

      if (user) this.initUser(user);
    }

    // adds user to all streets
    initUser(user) {
      if (!user) user = this.user;
      if (!user) return log("No user found to assign");
      this.lookupStreet.forEach((s) => s.setUser(user));
    }

    // creates leaflet markers
    initMarkers() {
      // adds streets routes
      this.lookupStreet.forEach((street) => {
        street.parts.forEach((p) => {
          if (!p.marker) p.setMarker();
        });
        street.updateStreetStats();
      });
    }

    // mechanism convertign all json data into objects
    // note: all nodes are only created once and share the reference to their street
    addStreet(name, parts, user = null, initMarker) {
      const street = this.lookupStreet.get(name) || new Street(name, parts);

      const allNodes = [];
      // iterate all parts
      // then add each part to a street
      for (let rawPart of parts) {
        const subdevided = this.subDevidePart(rawPart.coords);

        const nodes = new Map([
          ...subdevided.map((i) => [
            JSON.stringify(i),
            new StreetNode(JSON.stringify(i), rawPart.id, i, street),
          ]),
        ]);

        allNodes.push(...subdevided);

        const part = street.addPart(nodes, rawPart.id);

        // adds parts to street and saves it to this route for possible reverse lookup
        this.lookupPart.set(String(rawPart.id), part);
        // iterate nodes, might be duplicates (connecting street endpoints) so need to store as arrays
        // on the other hand, maybe duplciate values could be shared by a street, but we can't remove them from a street as a street with 1 node could be gone
        nodes.forEach((k, v) => {
          if (this.lookupNodes.has(v)) {
            this.lookupNodes.set(v, [...this.lookupNodes.get(v), k]);
          } else this.lookupNodes.set(v, [k]);
        });
      }

      if (user) street.setUser(user);
      if (!this.lookupStreet.has(name)) this.lookupStreet.set(name, street);

      if (initMarker) {
        this.initMarkers();
      }
      return allNodes;
    }

    // removes street from memory
    removeStreet(name) {
      const street = this.lookupStreet.get(name);
      if (!street)
        return log(
          "cannot remove street as route deos not contain it: " + name
        );

      const allCoords = [];
      street.parts.forEach((part) => {
        allCoords.push(...this.removePart(part.partId));
      });
      this.lookupStreet.delete(name);
      return allCoords;
    }

    // removes part from memory
    removePart(id) {
      const part = this.lookupPart.get(id);
      if (!part) {
        log("Cant delete part that is not here");
        return [];
      }
      const coords = [];
      part.nodes.forEach((node) => {
        this.lookupNodes.delete(node.id);
        coords.push(node.coords);
      });
      part.removeMarker();
      this.lookupPart.delete(part.partId);

      return coords;
    }

    subDevidePart(coords) {
      const response = [];
      // add in between waypoints between every 't' and 'c' point
      coords.reduce((t, c) => {
        if (t) {
          response.push(...getIntermediate(t, c));
          response.push(c);
        }
        return c;
      });
      return response;
    }

    setGobalStats() {
      let total = 0;
      for (let street of this.lookupStreet.values()) {
        total += street.updateStreetStats();
      }
      this.done = total / this.lookupStreet.size;
      window._progress.total = this.done;
      return this.done;
    }
  }

  /** Grid */
  class GridCell {
    constructor(nodes) {
      this.nodes = nodes;
      this.checked = false;
    }
  }

  // grid class
  class GridClass {
    constructor() {
      this.cells = new Map();
    }
    toCellCoord(x, y) {
      return JSON.stringify(toFixed(x, 4) + ";" + toFixed(y, 4));
    }
    init(nodes) {
      // create temporary gridf
      const tempGrid = {};
      nodes.forEach((p) => {
        const id = this.toCellCoord(p.x, p.y);
        tempGrid[id] = tempGrid.hasOwnProperty(id) ? [...tempGrid[id], p] : [p];
      });

      // create grid cells with temporary grid
      for (let [key, vals] of Object.entries(tempGrid)) {
        this.cells.set(key, new GridCell(vals));
      }
    }

    checkPointsInRadius(position) {
      if (!position || !position.lat) return;
      const id = this.toCellCoord(position.lat, position.lng);

      const cell = this.cells.get(id);
      if (cell && !cell.checked) {
        cell.nodes.forEach((node) => node.setChecked());
        cell.checked = true;
      }
    }
  }

  /** Server/ fake-api */
  // object serving as server for users
  class ServerClass {
    constructor() {
      this.users = {
        pol: { name: "pol", color: "#a47", activeRoute: null },
        ahmed: { name: "ahmed", color: "#4a7", activeRoute: null },
        louis: { name: "louis", color: "#47a", activeRoute: null },
        bram: { name: "bram", color: "#93f", activeRoute: null },
        annelies: { name: "annelies", color: "#f7a", activeRoute: null },
      };
      this.rawRoutes = new Map();
      this.rawStreets = new Map();
      this.rawParts = new Map();
    }

    // as routes are still generated, this workaround lets you add them
    // normally the server (or local) would contain all routes as static data
    boot() {
      // iterates all streets
      Object.values(routeData).forEach((street, idx) => {
        this.rawStreets.set(street.name, street.parts);
        for (let i of street.parts) {
          this.rawParts.set(String(i.id), i);
        }
      });

      const route1 = {};

      this.rawStreets.forEach((street, name) => {
        route1[name] = street;
      });

      this.rawRoutes.set("route-1", route1);
      this.rawRoutes.set("route-empty", {});
    }

    getRawRoute(id) {
      return this.rawRoutes.get(id);
    }

    // assing routes, would be normally done in beginning of day or on request or by admin
    assignRoute(userId, routeId) {
      const user = JSON.copy(this.users[userId]);
      const route = new RouteClass(routeId, user);
      this.users[userId].activeRoute = routeId;

      for (let [name, raw] of Object.entries(this.rawRoutes.get(routeId))) {
        route.addStreet(name, raw, user);
      }

      // reutrn new driver, should be done local somehow, maytbe just ahcgen name of this function
      return new DriverClass(userId + Math.random(), user, route);
    }

    // transfer: 1 - send request to other user
    // adds raw data with request
    // future update maybe only send data if user accepts, then start download
    handleTransferRequest(request) {
      let data;
      //street
      if (request.street) {
        data = this.rawStreets.get(request.name);
        // part
      } else {
        data = this.rawParts.get(request.id);
      }
      const response = { ...request, data: JSON.copy(data) };
      window._users.otherUser.recieveTransferRequest(response);
    }

    handleTransferResponse(response) {
      window._users.currentUser.recieveTransferResponse(response);
    }
  }

  // every trip a new instance is made as a user can be assigned a driver with a route
  class DriverClass {
    constructor(id, user, route) {
      route.initUser(user);

      this.user = user;
      this.route = route;
      this.destinations = [...this.route.lookupNodes.values()].flat();
      this.id = id;

      this.truck = getIcon(mapCenter);
      this.done = false;

      this.position = this.truck.getLatLng();
      this.currentDestination = null;

      this.pendingActions = new Map();
    }
    async init(useDataSet = false) {
      this.destinations = locationData;
    }
    // move will be real life location tracking so this system will be compleatly different
    move() {
      if (this.done || !this.destinations.length) return;
      this.position = this.destinations.next();

      if (
        !this.position ||
        this.position.current === this.destinations.length - 1
      ) {
        this.destinations.length = 0;
        this.done = true;
        return;
      }

      this.truck.setLatLng(this.position);
    }
    getPos() {
      return this.truck.getLatLng();
    }

    // transfer: 2 - get request from other user via server
    recieveTransferRequest(request) {
      let action;

      // select whole street or not
      if (request.street) {
        action = () =>
          this.route.addStreet(request.name, request.data, this.user, true);

        // only select part
      } else {
        action = () =>
          // dd(request);
          this.route.addStreet(
            request.data.name,
            [request.data],
            this.user,
            true
          );
      }
      this.pendingActions.set(request.id, action);

      window._mapFunctions.promptRecieveRequest(request);
    }

    // transfer: 1 - send request via server
    // also add action to remove street from own emmory as a pending action
    sendTransferRequest(from, to, wayId, wayStreetName, fullStreet) {
      const requestBody = {
        from: from,
        to: to,
        id: wayId,
        name: wayStreetName,
        street: fullStreet,
        routeId: this.route.id,
      };
      let action = () => null;

      // select whole street or not
      if (fullStreet) {
        if (!this.route.lookupStreet.has(wayStreetName))
          return log("Cannot request transfering an unknown street");
        action = () => {
          const current = this.destinations.current;
          const coordsToDelete = this.route.removeStreet(wayStreetName);
          const strCoords = coordsToDelete.map((i) => String(i));

          this.destinations = this.destinations.filter(
            (coord) => !strCoords.includes(String(coord))
          );

          this.destinations.current = current;
        };
        // only select part
      } else {
        if (!this.route.lookupPart.has(wayId)) {
          return log("Cannot request transfering an unknown part");
        }

        action = () => {
          const current = this.destinations.current;
          const coordsToDelete = this.route.removeStreet(wayStreetName);
          const strCoords = coordsToDelete.map((i) => String(i));

          this.destinations = this.destinations.filter(
            (coord) => !strCoords.includes(String(coord))
          );

          this.destinations.current = current;
        };
      }
      this.pendingActions.set(wayId, action);
      offlineServer.handleTransferRequest(requestBody);
    }

    // transfer: 3 - sending server response
    sendTransferResponse(accepted, id) {
      const response = {
        code: accepted ? 1 : 0,
        message: "",
        id: id,
      };
      if (accepted) {
        this.done = false;
        this.destinations.push(...this.pendingActions.get(id)());
      }
      this.pendingActions.delete(id);
      offlineServer.handleTransferResponse(response);
    }

    // transfer: 4 - recieve server response
    recieveTransferResponse(response) {
      const { id, code } = response;
      if (code) {
        this.pendingActions.get(id)();
      } else log("Request declined!");

      // clear peding actions cache
      this.pendingActions.delete(id);
    }
  }

  async function main() {
    Grid = new GridClass();
    offlineServer = new ServerClass();

    offlineServer.boot();
    // init routes for users
    // normally inited on each different device seperately
    window._users.currentUser = offlineServer.assignRoute("louis", "route-1");
    window._users.otherUser = offlineServer.assignRoute("ahmed", "route-empty");

    window._users.currentUser.route.initMarkers();

    const allc = [
      ...window._users.currentUser.route.lookupNodes.values(),
    ].flat();
    Grid.init(allc);
    window._users.currentUser.init();

    let iter = 0;
    while (!window._users.currentUser.done || iter > 2000000) {
      if (iter % 200 === 0) {
        window._users.currentUser.route.setGobalStats();
      }
      iter++;
      await sleep(0.01);
      window._users.currentUser.move();
      window._users.otherUser.move();

      Grid.checkPointsInRadius(window._users.currentUser.getPos());
    }
  }

  main();
};

module.exports = {
  initWithMap,
};
