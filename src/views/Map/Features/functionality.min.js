/**
 * This file is not suitable for a production environment
 */

const { useFetcher } = require("react-router-dom");

const initWithMap = (
  MAP,
  locationData,
  routeData,
  currentUser,
  fallbackIcon,
  otherUsers
) => {
  const { log } = console;

  let Grid, offlineServer;

  const mapCenter = [50.746, 3.631];
  const stepDestail = 0.0001;

  const LeafIcon = window.L.Icon.extend({
    options: {
      iconSize: [50, 30],
    },
  });

  /** Helpers */
  function sleep(s = 0.1) {
    return new Promise((resolve) => setTimeout(resolve, s * 1000));
  }

  function toFixed(nr, amt = 6) {
    return +nr.toFixed(amt);
  }

  function getDis(a, b) {
    return Math.hypot(b[0] - a[0], b[1] - a[1]);
  }

  JSON.copy = (a) => JSON.parse(JSON.stringify(a));

  Object.defineProperty(Array.prototype, "current", {
    value: 0,
    writable: true,
    enumerable: false,
  });

  Array.prototype.next = function () {
    if (this.current >= this.length - 1) this.current = -1;
    return this[this.current++];
  };

  Array.prototype.getCurrent = function () {
    return this.current;
  };

  function getPosTo(src, targ, dis) {
    const dx = targ[0] - src[0];
    const dy = targ[1] - src[1];
    let angle = Math.atan2(dy, dx);

    return [src[0] + dis * Math.cos(angle), src[1] + dis * Math.sin(angle)];
  }

  // truck icon
  function getIcon(coords, useObj = true) {
    return new window.L.marker(
      useObj.name === currentUser.name
        ? coords
        : coords.map((i) => i - Math.random() * 0.002),
      {
        icon: new LeafIcon({
          iconUrl: useObj.truckIcon ?? fallbackIcon,
          otherUsers,
        }),
      }
    ).addTo(MAP);
  }

  /** get itermediate points */
  function getIntermediate(a, b) {
    let steps = stepDestail;
    const res = [];
    let dis = Infinity;
    let c = null;
    let tracker = 0;

    while (dis > steps) {
      if (tracker > 1000) throw new Error("infinite loop at: getIntermediate");
      c = getPosTo(a, b, tracker);
      dis = getDis(c, b);
      tracker += steps;
      res.push(c.map((i) => toFixed(i, 6)));
    }
    return res;
  }

  /** Street & nodes */
  // a street node point
  class StreetNode {
    constructor(id, partId, coords, street) {
      this.coords = coords;
      this.partId = partId;
      this.street = street;
      this.x = coords[0];
      this.y = coords[1];

      this.checked = false;
    }
    setChecked() {
      if (this.checked) return;
      this.checked = true;
      this.street.updateStreetStats();
    }
  }

  // a street part exists out of multiple nodes
  // it also contains the SVG leaflet marker item, and the user
  class StreetPart {
    constructor(partId, nodes, street) {
      //this.id = id
      this.nodes = nodes;
      this.partId = partId;
      this.street = street;
      this.rawNodes = [...nodes.values()].map((i) => i.coords);

      this.marker = null;
      this.finished = false;
    }

    checkPartDone() {
      if (this.finished) return this.nodes.length;
      const progress = [...this.nodes.values()].filter((i) => i.checked).length;
      if (progress === this.nodes.length) {
        this.finished = true;
        this.marker.setStyle({ color: "green" });
      }

      return progress;
    }

    setMarker() {
      this.marker = window._mapFunctions.createMarker(
        this.partId,
        this.street,
        this.rawNodes
      );
    }
    removeMarker() {
      MAP.removeLayer(this.marker);
      this.marker = null;
    }
  }

  // a street exists out of multiple street parts
  class Street {
    constructor(name, rawParts) {
      this.name = name;
      this.parts = new Map();
      this.rawParts = rawParts;
      this.nodes = [];
      this.max = 0;
      this.progress = 0;
      this.done = false;
    }
    addPart(nodes, partId) {
      this.parts.set(this.parts.size, new StreetPart(partId, nodes, this));
      this.max += nodes.size;
      this.nodes.push(...nodes.values());

      return this.parts.get(this.parts.size - 1);
    }
    // adds user to all parts
    setUser(user) {
      this.user = user;
    }

    updateStreetStats() {
      let totalParts = 0;
      for (let part of this.parts.values()) {
        totalParts += part.checkPartDone();
      }
      totalParts /= this.parts.size;

      this.progress = totalParts;
      this.percentage = Math.round((this.progress / this.max) * 100);

      window._progress[this.name] = this.percentage;
      return this.percentage;
    }
  }

  // overview of all data, basically all data related to the roads
  class RouteClass {
    constructor(id) {
      this.id = id;
      // reverse lookup by street name
      this.lookupStreet = new Map();
      // store all streets by coordinates.
      // Used for reversed lookup the road by coordinates
      this.lookupNodes = new Map();
      // reverse lookup part of street in case of switching it to another user
      this.lookupPart = new Map();

      this.done = 0;
      this.todo = 100;
    }

    // adds user to all streets
    initUser(user) {
      if (!user) user = this.user;
      if (!user) return log("No user found to assign");
      this.lookupStreet.forEach((s) => s.setUser(user));
    }

    // creates leaflet markers
    initMarkers() {
      // adds streets routes
      this.lookupStreet.forEach((street) => {
        street.parts.forEach((p) => {
          if (!p.marker) p.setMarker();
        });
        street.updateStreetStats();
      });
    }

    // mechanism convertign all json data into objects
    // note: all nodes are only created once and share the reference to their street
    addStreet(name, parts, user = null, initMarker) {
      const street = this.lookupStreet.get(name) || new Street(name, parts);

      const allNodes = [];
      // iterate all parts
      // then add each part to a street
      for (let rawPart of parts) {
        const subdevided = this.subDevidePart(rawPart.coords);

        const nodes = new Map([
          ...subdevided.map((i) => [
            JSON.stringify(i),
            new StreetNode(JSON.stringify(i), rawPart.id, i, street),
          ]),
        ]);

        allNodes.push(...subdevided);

        const part = street.addPart(nodes, rawPart.id);

        // adds parts to street and saves it to this route for possible reverse lookup
        this.lookupPart.set(String(rawPart.id), part);
        // iterate nodes, might be duplicates (connecting street endpoints) so need to store as arrays
        // on the other hand, maybe duplciate values could be shared by a street, but we can't remove them from a street as a street with 1 node could be gone
        nodes.forEach((k, v) => {
          if (this.lookupNodes.has(v)) {
            this.lookupNodes.set(v, [...this.lookupNodes.get(v), k]);
          } else this.lookupNodes.set(v, [k]);
        });
      }

      if (user) street.setUser(user);
      if (!this.lookupStreet.has(name)) this.lookupStreet.set(name, street);

      if (initMarker) {
        this.initMarkers();
      }
      return allNodes;
    }
    // removes part from memory
    removePart(id) {
      const part = this.lookupPart.get(id);
      if (!part) {
        log("Cant delete part that is not here");
        return [];
      }
      const coords = [];
      part.nodes.forEach((node) => {
        this.lookupNodes.delete(node.id);
        coords.push(node.coords);
      });
      part.removeMarker();
      this.lookupPart.delete(part.partId);

      return coords;
    }

    subDevidePart(coords) {
      const response = [];
      // add in between waypoints between every 't' and 'c' point
      coords.reduce((t, c) => {
        if (t) {
          response.push(...getIntermediate(t, c));
          response.push(c);
        }
        return c;
      });
      return response;
    }

    updateGlobals() {
      let total = 0;
      for (let street of this.lookupStreet.values()) {
        total += street.updateStreetStats();
      }
      this.done = total / this.lookupStreet.size;
      window._progress.total = this.done;
      return this.done;
    }
  }

  /** Grid */
  class GridCell {
    constructor(nodes) {
      this.nodes = nodes;
      this.checked = false;
    }
  }

  // grid class
  class GridClass {
    constructor() {
      this.cells = new Map();
    }
    toCellCoord(x, y) {
      return JSON.stringify(toFixed(x, 4) + ";" + toFixed(y, 4));
    }
    init(nodes) {
      // create temporary gridf
      const tempGrid = {};
      nodes.forEach((p) => {
        const id = this.toCellCoord(p.x, p.y);
        tempGrid[id] = tempGrid.hasOwnProperty(id) ? [...tempGrid[id], p] : [p];
      });

      // create grid cells with temporary grid
      for (let [key, vals] of Object.entries(tempGrid)) {
        this.cells.set(key, new GridCell(vals));
      }
    }

    checkPointsInRadius(position) {
      if (!position || !position.lat) return;
      const id = this.toCellCoord(position.lat, position.lng);

      const cell = this.cells.get(id);
      if (cell && !cell.checked) {
        cell.nodes.forEach((node) => node.setChecked());
        cell.checked = true;
      }
    }
  }

  /** Server/ fake-api */
  // object serving as server for users
  class ServerClass {
    constructor() {
      this.rawRoutes = new Map();
      this.rawStreets = new Map();
      this.rawParts = new Map();
    }

    // as routes are still generated, this workaround lets you add them
    // normally the server (or local) would contain all routes as static data
    boot() {
      // iterates all streets
      Object.values(routeData).forEach((street, idx) => {
        this.rawStreets.set(street.name, street.parts);
        for (let i of street.parts) {
          this.rawParts.set(String(i.id), i);
        }
      });

      const route1 = {};

      this.rawStreets.forEach((street, name) => {
        route1[name] = street;
      });

      this.rawRoutes.set("route-1", route1);
      this.rawRoutes.set("route-empty", {});
    }
    // transfer: 1 - send request to other user
    // adds raw data with request
    // future update maybe only send data if user accepts, then start download
    handleTransferRequest(wayId, targetUser) {
      const data = this.rawParts.get(wayId);
      const response = {
        wayId: wayId,
        from: currentUser.name,
        to: targetUser,
        data: JSON.copy(data),
      };
      window._mapFunctions.promptSendRequest(response);
      // window._users[targetUser].recieveTransferRequest(response);
    }

    handleTransferResponse(response) {
      window._users.currentUser.recieveTransferResponse(response);
    }
  }

  // every trip a new instance is made as a user can be assigned a driver with a route
  class DriverClass {
    constructor(id, userObj, route) {
      this.id = id;
      this.name = userObj.userName;
      this.userName = this.name;
      this.route = route;

      this.destinations = []; //;[...this.route.lookupNodes.values()].flat();

      this.truck = getIcon(Object.values(mapCenter), userObj);
      this.done = false;

      this.position = this.truck.getLatLng();
      this.currentDestination = null;

      this.pendingAction = null;
    }
    init(useDataSet = false) {
      if (useDataSet) {
        this.destinations = locationData;
      }
      this.user = window._users[this.name];
      this.route.initUser(this);
    }
    // move will be real life location tracking so this system will be compleatly different
    move() {
      if (this.done || !this.destinations.length) return;
      this.position = this.destinations.next();

      if (
        !this.position ||
        this.position.current === this.destinations.length - 1
      ) {
        this.destinations.length = 0;
        this.done = true;
        return;
      }

      this.truck.setLatLng(this.position);
    }
    getPos() {
      return this.truck.getLatLng();
    }

    // transfer: 2 - get request from other user via server
    recieveTransferRequest(wayId, street, selectedUser) {
      const raw = offlineServer.rawParts.get(wayId);

      this.pendingAction = () => {
        this.route.addStreet(street.name, [raw], this, true);
      };
      window._mapFunctions.promptRecieveRequest(wayId, street, selectedUser);
    }

    // transfer: 1 - send request via server
    // also add action to remove street from own emmory as a pending action
    sendTransferRequest(to, wayId, wayStreetName) {
      const requestBody = {
        from: currentUser.name,
        to: to,
        id: wayId,
        name: wayStreetName,
        routeId: this.route.id,
      };

      if (!this.route.lookupPart.has(wayId)) {
        return log("Cannot request transfering an unknown part");
      }

      this.pendingAction = () => {
        const current = this.destinations.current;
        const coordsToDelete = this.route.removePart(wayId);
        const strCoords = coordsToDelete.map((i) => String(i));

        this.destinations = this.destinations.filter(
          (coord) => !strCoords.includes(String(coord))
        );

        this.destinations.current = current;
      };

      offlineServer.handleTransferRequest(requestBody);
    }

    // transfer: 3 - sending server response
    sendTransferResponse(accepted, id) {
      const response = {
        code: accepted ? 1 : 0,
        message: "",
        id: id,
      };
      if (accepted) {
        this.done = false;
        if (this.pendingAction) {
          const r = this.pendingAction();
          if (r) {
            this.destinations.push(r);
          }
        } else {
          log("no pending aciton --@sendTransferResponse");
        }
      }
      this.pendingAction = null;
      offlineServer.handleTransferResponse(response);
    }

    // transfer: 4 - recieve server response
    recieveTransferResponse(response) {
      if (response) {
        if (this.pendingAction) {
          const r = this.pendingAction();
          if (r) {
            this.destinations.push(r);
          }
        } else {
          log("no pending aciton @-recieveTransferResponse");
        }
      } else log("Request declined!");

      // clear peding actions cache
      this.pendingAction = null;
    }
  }

  // assing routes, would be normally done in beginning of day or on request or by admin
  const assignRoute = (userObj, routeName) => {
    const route = new RouteClass(routeName);

    for (let [name, raw] of Object.entries(
      offlineServer.rawRoutes.get(routeName)
    )) {
      route.addStreet(name, raw);
    }
    // reutrn new driver, should be done local somehow, maytbe just ahcgen name of this function
    return new DriverClass(userObj.userName + Math.random(), userObj, route);
  };

  // MAIN init function
  (async () => {
    Grid = new GridClass();
    offlineServer = new ServerClass();
    offlineServer.boot();

    // init routes for users
    for (let user of otherUsers) {
      window._users[user.name] = assignRoute(user, "route-empty");
      window._users[user.name].init(false);
    }
    window._users.currentUser = assignRoute(currentUser, "route-1");
    window._users.currentUser.route.initMarkers();
    window._users.currentUser.init(true);

    const allc = [
      ...window._users.currentUser.route.lookupNodes.values(),
    ].flat();
    Grid.init(allc);

    const usersRef = Object.values(window._users);
    let iter = 0;
    while (!window._users.currentUser.done || iter > 2000000) {
      // update every 2.5 sec (sleep 0.05 * 50)
      if (iter % 50 === 0) {
        window._users.currentUser.route.updateGlobals();
      }
      iter++;
      await sleep(0.05);
      for (let u of usersRef) {
        if (u?.move && u.destinations.length && !u.done) u.move();
      }
      Grid.checkPointsInRadius(window._users.currentUser.getPos());
    }
  })();
};

module.exports = {
  initWithMap,
};
